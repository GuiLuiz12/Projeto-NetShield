import json
import glob
import sqlite3
from datetime import datetime
import os
import logging
import sys
import re
from typing import Optional, Dict, List, Any, Tuple

# Configuração de logging (sem alterações)
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('processor.log', mode='w'),
        logging.StreamHandler()
    ]
)
logger = logging.getLogger(__name__)

class DatabaseManager:
    """
    Classe refatorada para gerenciar um banco de dados com tabelas permanentes.
    """
    def __init__(self, db_name: str = 'vulnerabilities.db'):
        self.db_name = db_name
        self.conn = None

    def __enter__(self):
        self.conn = sqlite3.connect(self.db_name)
        self.conn.execute("PRAGMA foreign_keys = ON")
        # Ao conectar, garante que as tabelas permanentes existam
        self.create_permanent_tables()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        if self.conn:
            if exc_type is None:
                self.conn.commit()
            else:
                self.conn.rollback()
            self.conn.close()

    def create_permanent_tables(self):
        """
        Cria as tabelas permanentes (scans, hosts, vulnerabilities, ports)
        se elas ainda não existirem.
        """
        cursor = self.conn.cursor()
        
        # Tabela mestre para registrar cada sessão de scan (execução do script)
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_session_time TEXT NOT NULL
            )
        ''')
        
        # Tabela única para todos os hosts escaneados
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS hosts (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id INTEGER NOT NULL,
                ip TEXT NOT NULL,
                risk_score REAL DEFAULT 0.0,
                network TEXT,
                FOREIGN KEY(scan_id) REFERENCES scans(id) ON DELETE CASCADE
            )
        ''')
        
        # Tabela única para todas as vulnerabilidades encontradas
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS vulnerabilities (
                vuln_db_id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id INTEGER NOT NULL,
                cve_id TEXT NOT NULL,
                host_ip TEXT NOT NULL,
                cvss REAL NOT NULL,
                description TEXT DEFAULT '',
                FOREIGN KEY(scan_id) REFERENCES scans(id) ON DELETE CASCADE,
                UNIQUE(scan_id, cve_id, host_ip)
            )
        ''')
        
        # Tabela única para todas as portas abertas
        cursor.execute('''
            CREATE TABLE IF NOT EXISTS ports (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id INTEGER NOT NULL,
                host_ip TEXT NOT NULL,
                port INTEGER NOT NULL,
                protocol TEXT NOT NULL,
                service TEXT DEFAULT '',
                version TEXT DEFAULT '',
                FOREIGN KEY(scan_id) REFERENCES scans(id) ON DELETE CASCADE,
                UNIQUE(scan_id, host_ip, port, protocol)
            )
        ''')
        logger.info("Tabelas permanentes verificadas/criadas com sucesso.")

# Funções auxiliares (sem alterações)
def get_latest_reports_dir() -> Optional[str]:
    dirs = glob.glob('relatorios_scan_*')
    if not dirs:
        logger.error("Nenhum diretório de relatórios encontrado")
        return None
    latest_dir = max(dirs, key=os.path.getmtime)
    logger.info(f"Usando diretório mais recente: {latest_dir}")
    return latest_dir

def parse_report_file(file_path: str) -> Optional[Dict[str, Any]]:
    try:
        with open(file_path, 'r', encoding='utf-8') as f:
            data = json.load(f)
        # ... (lógica de parsing e validação do JSON continua a mesma)
        return data
    except Exception as e:
        logger.error(f"Erro ao processar {file_path}: {e}")
        return None

def calculate_risk_score(cves: List[Dict[str, Any]]) -> float:
    if not cves:
        return 0.0
    try:
        max_cvss = max(float(cve.get('cvss', 0)) for cve in cves)
        return min(max_cvss * 1.2, 10.0)
    except (TypeError, ValueError) as e:
        logger.warning(f"Erro ao calcular risk_score: {e}")
        return 0.0

# Nova função de importação
def import_data_with_scan_id(db_manager: DatabaseManager, data: Dict[str, Any], scan_id: int):
    """Importa dados de um único relatório para as tabelas permanentes usando um scan_id."""
    cursor = db_manager.conn.cursor()
    ip = data['ip']
    network = data.get('network', '')
    risk_score = calculate_risk_score(data.get('cves', []))

    # Insere host com o scan_id
    cursor.execute(
        'INSERT INTO hosts (scan_id, ip, risk_score, network) VALUES (?, ?, ?, ?)',
        (scan_id, ip, risk_score, network)
    )

    # Insere portas com o scan_id
    for port in data.get('open_ports', []):
        cursor.execute(
            'INSERT OR IGNORE INTO ports (scan_id, host_ip, port, protocol, service, version) VALUES (?, ?, ?, ?, ?, ?)',
            (scan_id, ip, port.get('port'), port.get('protocol', 'tcp'), port.get('service', ''), port.get('version', ''))
        )

    # Insere vulnerabilidades com o scan_id
    for cve in data.get('cves', []):
        cve_id = cve.get('id', f"vuln_{ip}_{datetime.now().timestamp()}")
        cursor.execute(
            'INSERT OR IGNORE INTO vulnerabilities (scan_id, cve_id, host_ip, cvss, description) VALUES (?, ?, ?, ?, ?)',
            (scan_id, cve_id, ip, cve.get('cvss', 0.0), cve.get('description', ''))
        )

# Lógica principal de processamento refatorada
def process_reports(db_manager: DatabaseManager, directory: str) -> Optional[int]:
    """
    Processa todos os relatórios:
    1. Cria uma nova entrada de sessão de scan.
    2. Usa o ID dessa sessão para inserir todos os dados.
    """
    report_paths = glob.glob(os.path.join(directory, 'scan_*_*.json'))
    if not report_paths:
        logger.warning(f"Nenhum relatório JSON encontrado em '{directory}'")
        return None

    try:
        cursor = db_manager.conn.cursor()
        
        # 1. Cria UMA entrada para esta sessão de scan e pega o ID dela
        now = datetime.now().isoformat()
        cursor.execute('INSERT INTO scans (scan_session_time) VALUES (?)', (now,))
        scan_id = cursor.lastrowid
        logger.info(f"Nova sessão de scan registrada com ID: {scan_id}")

        # 2. Itera sobre cada relatório e insere os dados
        imported_count = 0
        for report_path in report_paths:
            data = parse_report_file(report_path)
            if data:
                import_data_with_scan_id(db_manager, data, scan_id)
                imported_count += 1
        
        logger.info(f"{imported_count}/{len(report_paths)} relatórios importados para a sessão de scan ID {scan_id}.")
        return scan_id

    except sqlite3.Error as e:
        logger.error(f"Erro no processamento dos relatórios: {e}")
        db_manager.conn.rollback()
        return None

def main():
    try:
        logger.info("Iniciando processamento de relatórios com a nova estrutura.")
        
        with DatabaseManager() as db_manager:
            if len(sys.argv) > 1:
                directory = sys.argv[1]
            else:
                directory = get_latest_reports_dir()
                if not directory:
                    return 1
            
            # Processa os relatórios e obtém o ID da sessão de scan
            new_scan_id = process_reports(db_manager, directory)
            
            if new_scan_id:
                print("\n" + "="*50)
                print(f"  DADOS IMPORTADOS COM SUCESSO!")
                print(f"  Sessão de Scan ID: {new_scan_id}")
                print("="*50 + "\n")
                
            else:
                print("\nNenhum dado foi importado. Verifique o log 'processor.log' para mais detalhes.")
                return 1

        return 0
            
    except Exception as e:
        logger.critical(f"Erro fatal no script: {e}", exc_info=True)
        return 1

if __name__ == "__main__":
    sys.exit(main())