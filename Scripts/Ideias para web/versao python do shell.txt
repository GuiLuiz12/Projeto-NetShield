import subprocess
import json
import os
import re
from datetime import datetime
from typing import List, Dict, Optional, Tuple
import logging
from pathlib import Path

class VulnerabilityScanner:
    def __init__(self, network: str = None):
        self.network = network or self.detect_network()
        self.report_dir = None
        self.logger = logging.getLogger(__name__)
        
    def detect_network(self) -> str:
        """Detecta a rede automaticamente"""
        try:
            result = subprocess.run(
                ['ip', '-o', '-f', 'inet', 'addr', 'show'],
                capture_output=True,
                text=True,
                check=True
            )
            networks = re.findall(r'(\d+\.\d+\.\d+\.\d+/\d+)', result.stdout)
            return networks[0] if networks else '192.168.1.0/24'
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Erro ao detectar rede: {e}")
            return '192.168.1.0/24'

    def verify_dependencies(self) -> bool:
        """Verifica e instala dependências necessárias"""
        dependencies = {
            'nmap': {
                'install': ['sudo', 'apt', 'update', '&&', 'sudo', 'apt', 'install', '-y', 'nmap'],
                'check': ['which', 'nmap']
            },
            'vulners.nse': {
                'url': 'https://github.com/vulnersCom/nmap-vulners/raw/master/vulners.nse',
                'path': '/usr/share/nmap/scripts/vulners.nse'
            },
            'http-vulners.nse': {
                'url': 'https://raw.githubusercontent.com/scipag/vulscan/master/http-vulners-regex.nse',
                'optional': True
            },
            'ssh-enum-algos.nse': {
                'url': 'https://raw.githubusercontent.com/scipag/vulscan/master/ssh-vulners.nse',
                'optional': True
            }
        }

        try:
            # Verificar nmap
            if not self._check_command(dependencies['nmap']['check']):
                self.logger.info("Instalando nmap...")
                subprocess.run(' '.join(dependencies['nmap']['install']), shell=True, check=True)

            # Verificar scripts NSE
            for name, config in dependencies.items():
                if name == 'nmap':
                    continue
                
                path = config.get('path', f"/usr/share/nmap/scripts/{name}")
                if not os.path.exists(path):
                    if config.get('optional', False):
                        self.logger.warning(f"Script opcional {name} não encontrado")
                        continue
                    
                    self.logger.info(f"Instalando {name}...")
                    subprocess.run(['sudo', 'wget', '-q', config['url'], '-O', path], check=True)
            
            # Atualizar banco de dados de scripts
            subprocess.run(['sudo', 'nmap', '--script-updatedb'], check=True)
            return True
        
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Falha ao instalar dependências: {e}")
            return False

    def _check_command(self, cmd: List[str]) -> bool:
        """Verifica se um comando está disponível"""
        try:
            subprocess.run(cmd, capture_output=True, check=True)
            return True
        except subprocess.CalledProcessError:
            return False

    def scan_network(self) -> Dict[str, Dict]:
        """Executa o scan em toda a rede"""
        self.report_dir = f"relatorios_scan_{datetime.now().strftime('%Y%m%d_%H%M')}"
        os.makedirs(self.report_dir, exist_ok=True)
        
        active_hosts = self._discover_hosts()
        results = {}
        
        for ip in active_hosts:
            self.logger.info(f"Scanning host: {ip}")
            results[ip] = self.scan_host(ip)
            
        return results

    def _discover_hosts(self) -> List[str]:
        """Descobre hosts ativos na rede"""
        try:
            result = subprocess.run(
                ['sudo', 'nmap', '-sn', self.network, '-oG', '-'],
                capture_output=True,
                text=True,
                check=True
            )
            return re.findall(r'(\d+\.\d+\.\d+\.\d+)', result.stdout)
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Falha ao descobrir hosts: {e}")
            return []

    def scan_host(self, ip: str) -> Dict:
        """Executa scan completo em um único host"""
        try:
            # Scan inicial
            tmp_file = os.path.join(self.report_dir, f"scan_{ip}.tmp")
            scan_cmd = [
                'sudo', 'nmap', '-sV', 
                '--script', 'vulners', 
                '--script-args', 'mincvss=5.0',
                '-T4', '--top-ports', '1000',
                '-oN', tmp_file,
                ip
            ]
            
            subprocess.run(scan_cmd, check=True)
            
            # Verifica se precisa de scan completo
            with open(tmp_file, 'r') as f:
                content = f.read()
                if re.search(r'open.*(http|ssl|ssh|rdp|ftp|smtp)', content):
                    self.logger.info(f"Serviços críticos detectados em {ip}, executando scan completo...")
                    full_scan_cmd = [
                        'sudo', 'nmap', '-sV', 
                        '--script', 'vulners and safe',
                        '-p-', '--min-rate', '5000',
                        '-oN', tmp_file + '.full',
                        ip
                    ]
                    subprocess.run(full_scan_cmd, check=True)
                    
                    # Combina resultados
                    with open(tmp_file + '.full', 'r') as full_scan:
                        content += full_scan.read()
                    os.unlink(tmp_file + '.full')
            
            # Processa resultados
            open_ports = self._parse_open_ports(content)
            cves = self._parse_cves(content)
            recommendations = self._generate_recommendations(content)
            
            # Gera relatório JSON
            report = {
                'ip': ip,
                'date': datetime.now().isoformat(),
                'network': self.network,
                'open_ports': open_ports,
                'cves': cves,
                'recommendations': recommendations
            }
            
            json_file = os.path.join(self.report_dir, f"scan_{ip}.json")
            with open(json_file, 'w') as f:
                json.dump(report, f, indent=2)
                
            return report
            
        except subprocess.CalledProcessError as e:
            self.logger.error(f"Falha ao escanear host {ip}: {e}")
            return {
                'ip': ip,
                'error': str(e)
            }
        finally:
            if os.path.exists(tmp_file):
                os.unlink(tmp_file)

    def _parse_open_ports(self, content: str) -> List[Dict]:
        """Extrai portas abertas do resultado do nmap"""
        ports = []
        pattern = r'(\d+)/(tcp|udp)\s+open\s+(\S+)(?:\s+(.*))?'
        
        for match in re.finditer(pattern, content):
            port, protocol, service, version = match.groups()
            ports.append({
                'port': int(port),
                'protocol': protocol,
                'service': service,
                'version': version.strip() if version else ''
            })
            
        return ports

    def _parse_cves(self, content: str) -> List[Dict]:
        """Extrai CVEs do resultado do nmap"""
        cves = []
        pattern = r'(CVE-\d{4}-\d+)(?:\s+(\d+\.\d+))?(?:\s+(.*))?'
        
        for match in re.finditer(pattern, content):
            cve_id, cvss, description = match.groups()
            cves.append({
                'id': cve_id,
                'cvss': float(cvss) if cvss else 0.0,
                'description': description.strip() if description else ''
            })
            
        return cves

    def _generate_recommendations(self, content: str) -> List[str]:
        """Gera recomendações baseadas nos serviços encontrados"""
        recommendations = []
        services = {
            'http': "Verificar headers de segurança e atualizar servidor web",
            'ssl': "Verificar certificados e desativar protocolos inseguros (SSLv2/SSLv3)",
            'ssh': "Desativar login root e usar autenticação por chaves",
            'msrpc': "Restringir acesso via firewall e verificar atualizações",
            'ftp': "Desativar FTP não criptografado (usar SFTP/FTPS)"
        }
        
        for service, recommendation in services.items():
            if re.search(fr'open.*{service}', content):
                recommendations.append(f"[{service.upper()}] {recommendation}")
                
        # Recomendações gerais
        recommendations.extend([
            "Atualizar todos os serviços listados",
            "Fechar portas não utilizadas",
            "Implementar regras de firewall específicas",
            "Monitorar logs de acesso aos serviços expostos"
        ])
        
        return recommendations